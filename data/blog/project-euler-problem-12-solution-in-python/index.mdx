---
title: "Project Euler: Problem 12 Solution in Python"
published: true
createdAt: 2014-10-30T20:58:04.000Z
updatedAt: 2019-01-22T04:52:34.920Z
categories:
  - Programming
  - Project Euler
  - Python
---

## The Problem States

```text
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number
would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
1: 1
3: 1,3
6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
```

## My Solution

From reading the [Triangular Number](http://en.wikipedia.org/wiki/Triangular_number) article on Wikipedia, I can see
that the formula for finding the (n)th triangular number is this:

<BlockMath math="T_n = \sum_{k=1}^n k=1 + 2 + 3 + ... + n = \frac{n(n+1)}{2} = \dbinom{n+1}{2}" />

I wrote a function for finding that number. I then had to find all the factors of that number and pull the first one
with over 500 factors. Based on my prime factoring functionÂ I made for problem 3

```python
#Returns all of the factors of a number, the last factor is the number
def all_factors(x):
    #I should look for factors under the square root of x and add them only if x / it == 0?
    factors = []
    root = int((x ** .5) + 1)
    divisors = [i for i in range(1, root)]
    for i in divisors:
        j = x / i
        if x % i == 0 and x % j == 0 and j != i:
            factors.append(i)
            factors.append(int(j))
        elif j == i:
            factors.append(i)
    factors.sort()
    return factors
```

It turns out that there is a more efficient way to do things since there is a formula for finding how many factors a
number is made from by just using the prime factors. Prime factoring still uses about the same amount of trial
divisions, but it spends a lot less time and memory appending numbers to lists which seems to take a lot of resources.
The formula goes like this...

<BlockMath math="prime\;factors\;of\;12\;are\;[2,2,3]" />
<BlockMath math="2^2 * 3^1:\;add\;one\;to\;each\;exponent\;and\;then\;multiply\;the\;exponents" />
<BlockMath math="to\;get\;the\;number\;of\;factors\;of\;12:\;2^2 * 3^1 = 3 * 2 = 6\;factors\;in\;12" />
<BlockMath math="the\;factors\;of\;12\;are\;[1,2,3,4,6,12]" />

So, in the end, the quickest way to go about doing this was to use the triangle number function, prime factor
function, and then my number of factors function.

```python
import time
start_time = time.clock()


# Returns the (x)th triangle number
# Based on the formula above
def triangle(x):
    x = x * (x + 1) / 2
    x = int(x)
    return x


# Returns the prime factors of x in a list
# This is a function that I have used before in a previous problem
def prime_factors(x):
    factors = []
    div = 2
    while div ** 2 <= x:
        while x % div == 0:
            factors.append(div)
            x /= div
       div += 1
    if x > 1:
        factors.append(x)
    if len(factors) == 1:
        factors.append(1)
    return factors


# Returns number of factors based on prime factor list
# I wrote this function based on the formula above
def num_of_factors(x):
    factors = []
    for i in x:
        if len(x) > 0:
            #Counts the number of times a factor occurs and then adds one
            #and appends it to a list. (if it finds 2^2 it will append 3)
            #The second '[i for i]' part would remove that number from the
            #Prime factor list
            factors.append(x.count(x[0]) + 1)
            x = [i for i in x if i != x[0]]
    answer = 1
    for i in factors:
        answer *= i
    return answer

# This is my loop that will actually find the triangle number with more than 500 factors
n = 1
factors = 0
while factors < 500:
    factors = num_of_factors(prime_factors(triangle(n)))
    n += 1
else:
    #I had to use (n - 1) because after it found the answer it still added 1 to n before exiting
     print('the:', n - 1, 'th', 'triangle number:', triangle(n - 1), '\n'
          'has', factors, 'factors')


print()
print('finished in:', time.clock() - start_time, 'seconds')
```

## The Output

```text
the: 12375 th triangle number: 76576500
has 576 factors

finished in: 5.372077867096354 seconds
```
